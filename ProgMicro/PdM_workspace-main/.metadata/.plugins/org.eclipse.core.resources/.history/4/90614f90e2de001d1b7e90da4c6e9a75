/*
 * DigitalLeve.c
 *
 *  Created on: 18 abr. 2023
 *      Author: denis
 */

#include "API_delay.h"
#include "API_debounce.h"
#include "mpu9265_SPI.h"

/* Accelerometer reference to determine the inclination plane*/
#define ACCEL_REF	32768 // (2^15) --> half range for each plane
#define CALIB_POS 50000

typedef enum{
	IDLE,
	MEASURE,
	CONFIG
} LevelState_t;

static LevelState_t actualState;

/* @brief: Start digital level FSM in idle state
 * @param: None
 * @retval: None
 * */
void digitalLevInit(){
	actualState = IDLE;
}



/* @brief: Inform the actual angle of the X axis
 * @param: None
 * @retval: The actual angle read from mpu9265 accelerometer.
 * This could be a value from -90° to 90°
 * */
uint8_t shiftBits = 1;
uint8_t accelRes = 2;

int16_t getXAngle(){
	int16_t retAngle;
	uint16_t xAccel = MPUReadAccelXAxis();
	/* See in which plane is inclined to determine how
	 * to calculate the angle*/
	/* Positive angles */
	if(xAccel > ACCEL_REF){
		retAngle = 90 - (int16_t)((xAccel-CALIB_POS)/173);
	}
	/* Negative angles */
	else{
		retAngle = (int16_t)-xAccel/178;
	}
	return (retAngle);
}

int16_t getYAngle(){
	int16_t retAngle;
	uint16_t yAccel = MPUReadAccelYAxis();
	/* See in which plane is inclined to determine how
	 * to calculate the angle*/
	/* Positive angles */
	if(yAccel > ACCEL_REF){
		retAngle = 90 - (int16_t)((yAccel-CALIB_POS)/173);
	}
	/* Negative angles */
	else{
		retAngle = (int16_t)-yAccel/178;
	}
	return (retAngle);
}
