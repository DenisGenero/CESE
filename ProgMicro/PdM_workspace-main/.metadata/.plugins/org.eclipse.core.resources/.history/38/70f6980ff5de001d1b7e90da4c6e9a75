/*
 * DigitalLeve.c
 *
 *  Created on: 18 abr. 2023
 *      Author: denis
 */

#include "API_delay.h"
#include "Console.h"
#include "API_debounce.h"
#include "mpu9265_SPI.h"
#include "Neopixel4x4.h"

/* Accelerometer reference to determine the inclination plane*/
#define ACCEL_REF	32768 // (2^15) --> half range for each plane
#define CALIB_POS 50000

typedef enum{
	IDLE,
	MEASURE,
	CONFIG
} LevelState_t;

static LevelState_t actualState;
static uint8_t idleMsg[] = "Dispositivo en REPOSO. Pulse el bot처n para comenzar a medir\r\n";
static uint8_t measureMsg[] = "Dispositivo en medici처n. Lecturas obtenidas: \r\n";
//TODO: Config message
static uint8_t xDataMsg [] = "Plano x: ";
static uint8_t yDataMsg [] = "Plano y: ";

int16_t xAngle, yAngle;
int16_t xOffset = 10;
int16_t yOffset = 10;

/* @brief: Inform the actual angle of the X axis
 * @param: None
 * @retval: The actual angle read from mpu9265 accelerometer.
 * This could be a value from -90째 to 90째
 * */

int16_t getXAngle(){
	int16_t retAngle;
	uint16_t xAccel = MPUReadAccelXAxis();
	/* See in which plane is inclined to determine how
	 * to calculate the angle*/
	/* Positive angles */
	if(xAccel > ACCEL_REF){
		retAngle = 90 - (int16_t)((xAccel-CALIB_POS)/173);
	}
	/* Negative angles */
	else{
		retAngle = (int16_t)-xAccel/178;
	}
	return (retAngle);
}

int16_t getYAngle(){
	int16_t retAngle;
	uint16_t yAccel = MPUReadAccelYAxis();
	/* See in which plane is inclined to determine how
	 * to calculate the angle*/
	/* Positive angles */
	if(yAccel > ACCEL_REF){
		retAngle = 90 - (int16_t)((yAccel-CALIB_POS)/173);
	}
	/* Negative angles */
	else{
		retAngle = (int16_t)-yAccel/178;
	}
	return (retAngle);
}

/* @brief: Start digital level FSM in idle state
 * @param: None
 * @retval: None
 * */
void digitalLevInit(){
	neopixelInit();
	debounceFSM_init();
	actualState = IDLE;
}

void digitalLevUpdate(){
	debounceFSM_update();
	switch(actualState){
	case IDLE:
		/* Reset neopixel matrix*/
		turnAllOff();
		/* Indicate idle mode */
		turnCenterOn(1, 0, 0);
		/* Clear serial console */
		ConsoleClear();
		/* Indicate idle mode */
		ConsolePrintStr(idleMsg);
		if (readKey()){
			actualState = MEASURE;
		}
		// TODO: Implement configuration mode
		/*if(ConsoleNewData){
		 * actualState = CONFIG;
		 * */
		break;
	case MEASURE:
//		/* Reset neopixel matrix*/
//		turnAllOff();
		/* Clear serial console */
//		ConsoleClear();
		/* Indicate measure mode */
		ConsolePrintStr(measureMsg);
		if (readKey()){
			actualState = IDLE;
		}
		xAngle = getXAngle();
		yAngle = getYAngle();
		/* Show in console actual degrees read */
		ConsolePrintStr(xDataMsg);
		ConsolePrintDeg(xAngle);
		ConsolePrintStr(yDataMsg);
		ConsolePrintDeg(yAngle);
		/* Show if there is inclination */
		bool moved = false;
		/* Compound movement: */
		if(xAngle > xOffset){
			moved = true;
			turnAllOff();
			if(yAngle > yOffset){
				turnLedOn(0, 0, 1, 0, 0);
				turnLedOn(0, 1, 1, 0, 0);
				turnLedOn(1, 0, 1, 0, 0);
			}
			if (yAngle < -yOffset){
				turnLedOn(2, 0, 1, 0, 0);
				turnLedOn(3, 0, 1, 0, 0);
				turnLedOn(3, 1, 1, 0, 0);
			}
			if (-yOffset < yAngle && yAngle < yOffset){
				turnColumnOn(0, 1, 0, 0);
			}
		}
		if(xAngle < -xOffset){
			moved = true;
			turnAllOff();
			if(yAngle > yOffset){
				turnLedOn(0, 2, 1, 0, 0);
				turnLedOn(0, 3, 1, 0, 0);
				turnLedOn(1, 3, 1, 0, 0);
			}
			if (yAngle < -yOffset){
				turnLedOn(2, 3, 1, 0, 0);
				turnLedOn(3, 2, 1, 0, 0);
				turnLedOn(3, 3, 1, 0, 0);
			}
			if (-yOffset < yAngle && yAngle < yOffset){
				turnColumnOn(3, 1, 0, 0);
			}
		}
		if((!moved) && (yAngle > yOffset)){
			turnAllOff();
			turnRowOn(0, 1, 0, 0);
			moved = true;
		}
		if ((!moved) && (yAngle < -yOffset)){
			turnAllOff();
			turnRowOn(3, 1, 0, 0);
			moved = true;
		}
		if (!moved){
			turnAllOff();
			/* Indicate correct leveling */
			turnCenterOn(0, 1, 0);
		}
		break;
	case CONFIG:
		break;

	}
}
