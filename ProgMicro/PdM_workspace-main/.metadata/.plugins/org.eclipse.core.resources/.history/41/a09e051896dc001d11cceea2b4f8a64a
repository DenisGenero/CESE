/*
 * mpu9265_SPI.c
 *
 *  Created on: 16 abr. 2023
 *      Author: denis
 */
#include "mpu9265_SPI.h"

/* mpu9265 register's directions macros */
#define GYRO_RESOLUTION		27	// Register 27 (8 bits):
#define GYRO_250_RES		0	// 0bx00000000
#define GYRO_500_RES		8	// 0bx00001000
#define GYRO_1000_RES		16	// 0bx00010000
#define GURO_2000_RES		24	// 0bx00011000

#define ACCEL_RESOLUTION 	28	// Register 28 (8 bits):
#define ACCEL_2G_RES		0	// 0bx00000000
#define ACCEL_4G_RES		8	// 0bx00001000
#define ACCEL_8G_RES		16	// 0bx00010000
#define ACCEL_16G_RES		24	// 0bx00011000

#define ACCEL_DATA			59
#define ACCEL_XAXIS			59
#define ACCEL_YAXIS			61
#define ACCEL_ZAXIS			63

#define TEMPERATURE			65

#define GYRO_DATA			67
#define GYRO_XAXIS			67
#define GYRO_YAXIS			69
#define GYRO_ZAXIS			71


/* ################# Private functions ################# */
static void MPURead(uint8_t reg, uint8_t *data, uint8_t bytes){
	SPIRead(reg, data, bytes);
}

static void MPUWrite(uint8_t reg, uint8_t command){
//	reg = reg | command;
	CSEnable();
	SPIWrite(reg);
	SPIWrite(command);
	CSDisable();
}

static uint16_t converData(uint8_t msbData, uint8_t lsbData){
	uint16_t result = msbData<<8 | lsbData;
	return (result);
}

static void MPUAccelCalibration(uint8_t resolution){
	MPUWrite(ACCEL_RESOLUTION, resolution);
}

static void MPUGyroCalibration(uint8_t resolution){
	MPUWrite(GYRO_RESOLUTION, resolution);
}

/* ################# Public functions ################# */
/* Accelerometer functions */
void MPUReadAccel(uint8_t *data){
	/* Accelerometer gives 6 bytes of data:
	 * two bytes for each axis */
	uint8_t byteCount = 6;
	MPURead(ACCEL_DATA, data, byteCount);
}

uint16_t MPUReadAccelXAxis(){
	uint8_t byteCount = 2;
	uint8_t *data = &byteCount;
	MPURead(ACCEL_XAXIS, data, byteCount);
	uint16_t result = converData(data[0], data[1]);
	return(result);
}

uint16_t MPUReadAccelYAxis(){
	uint8_t byteCount = 2;
	uint8_t *data = &byteCount;
	MPURead(ACCEL_YAXIS, data, byteCount);
	uint16_t result = converData(data[0], data[1]);
	return(result);
}

uint16_t MPUReadAccelZAxis(){
	uint8_t byteCount = 2;
	uint8_t *data = &byteCount;
	MPURead(ACCEL_YAXIS, data, byteCount);
	uint16_t result = converData(data[0], data[1]);
	return(result);
}

void MPUSetAccel2G(){
	MPUAccelCalibration(ACCEL_2G_RES);
}

void MPUSetAccel4G(){
	MPUAccelCalibration(ACCEL_4G_RES);
}

void MPUSetAccel8G(){
	MPUAccelCalibration(ACCEL_8G_RES);
}

void MPUSetAccel16G(){
	MPUAccelCalibration(ACCEL_16G_RES);
}

uint8_t MPUGetAccelResolution(){
	uint8_t data;
	MPURead(ACCEL_RESOLUTION, &data, 1);
	return(data);
}

/* Temperature sensor */
uint16_t MPUReadTemperature(){
	uint8_t byteCount = 2;
	uint8_t *data = &byteCount;
	MPURead(TEMPERATURE, data, byteCount);
	uint16_t result = converData(data[0], data[1]);
	return(result);
}

/* Gyroscope functions */
void MPUReadGyro(uint8_t *data){
	/* Gyroscope gives 6 bytes of data:
	 * two bytes for each axis */
	uint8_t byteCount = 6;
	MPURead(GYRO_DATA, data, byteCount);
}

uint16_t MPUReadGyroXAxis(){
	uint8_t byteCount = 2;
	uint8_t *data = &byteCount;
	MPURead(GYRO_XAXIS, data, byteCount);
	uint16_t result = converData(data[0], data[1]);
	return(result);
}

uint16_t MPUReadGyroYAxis(){
	uint8_t byteCount = 2;
	uint8_t *data = &byteCount;
	MPURead(GYRO_YAXIS, data, byteCount);
	uint16_t result = converData(data[0], data[1]);
	return(result);
}

uint16_t MPUReadGyroZAxis(){
	uint8_t byteCount = 2;
	uint8_t *data = &byteCount;
	MPURead(GYRO_ZAXIS, data, byteCount);
	uint16_t result = converData(data[0], data[1]);
	return(result);
}

void MPUSetGyro250(){
	MPUGyroCalibration(GYRO_250_RES);
}

void MPUSetGyro500(){
	MPUGyroCalibration(GYRO_500_RES);
}

void MPUSetGyro1000(){
	MPUGyroCalibration(GYRO_1000_RES);
}

void MPUSetGyro2000(){
	MPUGyroCalibration(GYRO_2000_RES);
}

uint8_t MPUGetGyroResolution(){
	uint8_t data;
	MPURead(GYRO_RESOLUTION, &data, 1);
	return(data);
}
