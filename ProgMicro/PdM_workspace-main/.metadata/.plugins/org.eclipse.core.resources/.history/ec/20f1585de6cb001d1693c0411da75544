
/* Includes ------------------------------------------------------------------*/
#include "API_debounce.h"

/* Private functions ---------------------------------------------------------*/

delay_t delay;

// TODO:
/* @brief
 * Tell the API if the button is pressed or released
 * @param  None
 * @retval true if the button is press, false if it is released*/
bool_t readKey(){
}

/* @brief
 * Toggle LED1 state whenever a press state is detected
 * @param  None
 * @retval None*/
void buttonPressed(){
	BSP_LED_Toggle(LED_GREEN);
}

/* @brief
 * Toggle LED3 state whenever a release state is detected
 * @param  None
 * @retval None*/
void buttonReleased(){
	BSP_LED_Toggle(LED_RED);
}

/* @brief
 * Initialize the Finite State Machine assuming that
 * the button is release (normal button state --> normal open)
 * @param  None
 * @retval None */
void debounceFSM_init(){
	/* Set the initial state --> normal state is open */
	actualState = BUTTON_UP;
	/* Load the de-bouncing time */
	delayInit(&delay, DEBOUNCE_TIME);
}

/* @brief
 * Ask for the actual state and determine if the button was hold down or up
 *  applying a de-bouncing method, that consist in check twice with a 40 milliseconds wait,
 *  if it was a real state change or a spurious mechanic noise.
 * @param  None
 * @retval None */
void debounceFSM_update(){
	switch(actualState){
		case BUTTON_UP:
			if(BSP_PB_GetState(BUTTON_USER)){
				/* Update to next state */
				actualState = BUTTON_FALLING;
				/* Start the delay count */
				delayRead(&delay);
			}
		break;

		case BUTTON_FALLING:
			/* Check for the de-bouncing time */
			if(delayRead(&delay)){
				/* If after de-bouncing time the button is still pressed, it is assumed
				 * that the user has pressed the button */
				if(BSP_PB_GetState(BUTTON_USER)) {
					/* Update to next state */
					actualState = BUTTON_DOWN;
					/* Toggle led */
					buttonPressed();
				}
				else{
					/* If spurious noise detected, return to previous state */
					actualState = BUTTON_UP;
				}
			}
		  break;

		case BUTTON_DOWN:
		  if(!BSP_PB_GetState(BUTTON_USER)){
			  /* Update to next state */
			  actualState = BUTTON_RISING;
			  /* Start the delay count */
			  delayRead(&delay);
		  }
		  break;

		case BUTTON_RISING:
			/* If after de-bouncing time the button is still released, it is assumed
			 * that the user has released the button */
			if(delayRead(&delay)){
				if(!BSP_PB_GetState(BUTTON_USER)){
					/* Update to next state */
					actualState = BUTTON_UP;
					/* Toggle led */
					buttonReleased();
				}
				else{
					/* If spurious noise detected, return to previous state */
					actualState = BUTTON_DOWN;
				}
			}
		  break;
	  default:
		  /* Defensive guard: if another state is loaded in actualState variable,
		   * return to the first state */
		  actualState = BUTTON_UP;
		  break;
	}

}
